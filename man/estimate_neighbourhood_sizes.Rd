% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_neighbourhood_sizes.R
\name{estimate_neighbourhood_sizes}
\alias{estimate_neighbourhood_sizes}
\title{estimate_neighbourhood_sizes}
\usage{
estimate_neighbourhood_sizes(
  x,
  reducedDim_name,
  k_grid = seq(10, 100, 10),
  order = 2,
  prop = 0.1,
  filtering = TRUE,
  k_init = 50,
  d = 30,
  cluster_id = NULL,
  plot_stat = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{x}{A \code{\linkS4class{SingleCellExperiment}} object}

\item{reducedDim_name}{Defines the slot in \code{reducedDim(x)} to use as the embedding for graph construction.}

\item{k_grid}{Vector of positive integers, defines how many neighbours to use for the neighbourhood assignment.}

\item{order}{In \code{c(1,2)}, defines which order of neighbours to use. Default \code{order = 2}.}

\item{prop}{Numerical, between 0 and 1, defines which fraction of cells to use as neighbourhood centres. Default \code{prop = 0.2}.}

\item{filtering}{In \code{c(TRUE,FALSE)}, defines whether to filter neighbourhoods (reduces computing time downstream). Default \code{filtering = TRUE}.}

\item{k_init}{Positive integer, defines how many neighbours to use for identifying \sQuote{index} cells. Default \code{k_init = 50}.}

\item{d}{Positive integer, defines how many dimensions from \code{reducedDim(x)} to use. Default \code{d = 30}.}

\item{cluster_id}{Character specifying which field in \code{colData(x)} to use for 'localised' neighbourhood size estimation.
This might be useful if dataset is rather big (which will result in an excessive running time).
In case \code{cluster_id} is provided, we will calculate neighbourhood size distribution within individual clusters and aggregate results
across clusters in order to speed up the process (note that it might result in slightly biased estimates).
Default \code{cluster_id = NULL}, in which case neighbourhood sizes will be estimated for the whole dataset.}

\item{plot_stat}{Boolean specifying whether to plot the stat. Default \code{plot_stat = TRUE}.}

\item{verbose}{Boolean specifying whether to print intermediate output messages. Default \code{verbose = TRUE}.}
}
\value{
\code{data.frame} object, in which each row corresponds to k and 5 columns correspond to min, q25, median, q75 and max of neighbourhood size distributions; also returns a boxplot
}
\description{
For a grid of \code{k}, returns neighbourhood size distribution; that will help a user to select appropriate \code{k}
}
\details{
This function returns an estimated distribution of neighbourhood sizes for different \code{k} values
(for the selected by user \code{order}; if you want to estimates for both 1st and 2nd \code{order}, run this twice with changing \code{order}).
This is useful to gauge whether the neighbourhood size distribution is appropriate for the selected \code{k}, since \code{\link{de_test_neighbourhoods}} takes a while to complete.

Note that this function also might take a while to complete on big datasets (> 70k cells), and in this case we provide an option to estimate neighbourhood
sizes within annotated clusters (passed in \code{cluster_id}), which will be considerably faster, however, might result in slightly biased estimates.
}
\examples{
require(SingleCellExperiment)
n_row = 500
n_col = 100
n_latent = 5
sce = SingleCellExperiment(assays = list(counts =
floor(matrix(rnorm(n_row*n_col), ncol=n_col)) + 4))
rownames(sce) = as.factor(1:n_row)
colnames(sce) = c(1:n_col)
sce$cell = colnames(sce)
reducedDim(sce , "reduced_dim") =
matrix(rnorm(n_col*n_latent), ncol=n_latent)
out = estimate_neighbourhood_sizes(sce, k_grid = c(5,10),
reducedDim_name = "reduced_dim")

}
